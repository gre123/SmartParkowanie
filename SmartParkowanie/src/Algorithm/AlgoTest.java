/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package Algorithm;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author Tomek
 */
public class AlgoTest extends javax.swing.JFrame {

    /**
     * Creates new form AlgoTest
     */
    public AlgoTest() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        txtStartLat = new javax.swing.JTextField();
        txtStartLon = new javax.swing.JTextField();
        txtEndLat = new javax.swing.JTextField();
        txtEndLon = new javax.swing.JTextField();
        btnFind = new javax.swing.JButton();
        txtMapFile = new javax.swing.JTextField();
        btnLoad = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextPane1 = new javax.swing.JTextPane();
        btnFindStartNode = new javax.swing.JButton();
        btnFindEndNode = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        txtStartLat.setText("50");

        txtStartLon.setText("19");

        txtEndLat.setText("50.08");

        txtEndLon.setText("19.85");

        btnFind.setText("Znajdź droge");
        btnFind.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnFindActionPerformed(evt);
            }
        });

        txtMapFile.setText("krakow.osm");

        btnLoad.setText("Wczytaj mape");
        btnLoad.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnLoadActionPerformed(evt);
            }
        });

        jScrollPane1.setViewportView(jTextPane1);

        btnFindStartNode.setText("Znajdź start");
        btnFindStartNode.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnFindStartNodeActionPerformed(evt);
            }
        });

        btnFindEndNode.setText("Znajdź koniec");
        btnFindEndNode.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnFindEndNodeActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(btnFind, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jScrollPane1)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                .addComponent(txtMapFile, javax.swing.GroupLayout.Alignment.LEADING)
                                .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                    .addComponent(txtStartLat, javax.swing.GroupLayout.PREFERRED_SIZE, 44, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                    .addComponent(txtStartLon, javax.swing.GroupLayout.PREFERRED_SIZE, 47, javax.swing.GroupLayout.PREFERRED_SIZE)))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(txtEndLat, javax.swing.GroupLayout.PREFERRED_SIZE, 44, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(txtEndLon, javax.swing.GroupLayout.PREFERRED_SIZE, 47, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addGap(36, 36, 36)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(btnFindEndNode, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                .addComponent(btnLoad, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(btnFindStartNode, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(17, 17, 17)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(txtMapFile, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(btnLoad))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(txtStartLat, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(txtStartLon, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(btnFindStartNode, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(txtEndLat, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(txtEndLon, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(btnFindEndNode, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnFind)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 14, Short.MAX_VALUE)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 221, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnFindActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnFindActionPerformed
        dijkstra = new Dijkstra();
        dijkstra.find(list, WIDTH, WIDTH);
    }//GEN-LAST:event_btnFindActionPerformed

    private void btnLoadActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnLoadActionPerformed
        list = new ArrayList<>();
        nodeList = new ArrayList<>();
        wayList = new ArrayList<>();
        try {
            parser(nodeList, wayList);
        } catch (IOException ex) {
            Logger.getLogger(AlgoTest.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_btnLoadActionPerformed

    private void btnFindStartNodeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnFindStartNodeActionPerformed
        start = findNode(nodeList, txtStartLat.getText(), txtStartLon.getText());
    }//GEN-LAST:event_btnFindStartNodeActionPerformed

    private void btnFindEndNodeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnFindEndNodeActionPerformed
        end = findNode(nodeList, txtEndLat.getText(), txtEndLon.getText());
    }//GEN-LAST:event_btnFindEndNodeActionPerformed
    private int findNode(ArrayList<TempNode> nodeList, String _Lat, String _Lon) {
        double lat = Double.parseDouble(_Lat);
        double lon = Double.parseDouble(_Lon);
        int result = -1;

        TempNode baseNode = new TempNode(1, lat, lon);
        int d = nodeList.size();
        double min_odl = nodeList.get(0).minus(baseNode);
        int min_id = nodeList.get(0).getId();

        for (int i = 1; i < d; i++) {
            double temp_odl = nodeList.get(i).minus(baseNode);
            if (temp_odl == 0) {
                return nodeList.get(i).getId();
            }
            if (min_odl > temp_odl) {
                min_id = i;
                min_odl = temp_odl;
            }
        }
        System.out.println(min_odl + "--");
        return nodeList.get(min_id).getId();
    }

    private void czytaj_f_graf(ArrayList<Node> lista) throws IOException {//funkcjia haszyjaca sie przyda
        BufferedReader br = new BufferedReader(new FileReader("mapa_nowa.txt"));
        StringBuilder sb = new StringBuilder();

        String s;
        String line = br.readLine();
        while (line != null) {

            int id1, id2, dl;
            int i = 1;
            line = line.replace("(", "");
            line = line.replace(")", "");
            String[] split = line.split(",");

            id1 = Integer.parseInt(split[0]);
            dl = Integer.parseInt(split[1]);
            id2 = Integer.parseInt(split[2]);

            int indeks = find_lista3(lista, id1);//tu jest wyszukiwanie binarne a moze byc w czasie stalym

            if (indeks != 0) {
            } else {
                lista.add(new Node());
                indeks = lista.size() - 1;
            }
            lista.get(indeks).setId(id1);
            Node ntemp;
            ntemp = new Node(dl, id2);
            Node pseek = lista.get(indeks);
            while (pseek.getNext() != null) {
                pseek = pseek.getNext();
            }
            pseek.setNext(ntemp);

        }
        br.close();
        Collections.sort(list, new ComparatorID());
    }

    private int find_lista3(ArrayList<Node> lista, int id) {
        int d = lista.size();
        if (d == 0) {
            return 0;
        }
        if (lista.get(d - 1).getId() == id) {
            return d - 1;
        }
        return 0;
    }

    private void parser(ArrayList<TempNode> node_list, ArrayList<TempWay> way_list) throws FileNotFoundException, IOException {

        BufferedReader br = new BufferedReader(new FileReader(txtMapFile.getText()));

        String line = br.readLine();
        boolean way = false;// zeby czytal droge
        int i;
        while (line != null) {
            i = 3;

            if (!way   {
                line.charAt(2) == '<'  
            }
            get_slowo(line, i).equals("way id")
            
                ) {
                way = true;
            }
            if (!way) {
                czytaj_nody(line, node_list);
            } else {
                czytaj_droge(line, way_list);
            }
            line = br.readLine();
        }

        br.close();
        zapis_mapy(node_list, way_list);
    }

    private void czytaj_nody(String linijka, ArrayList<TempNode> node_list) {
        int temp_id = 0;
        double temp_dlugosc = 0;
        double temp_szerokosc = 0;
        boolean right = false;

        int d = linijka.length();
        for (int i = 0; i < d; i++) {

            if (Character.isLetter(linijka.charAt(i))) {
                String temp_String = get_slowo(linijka, i);

                if (temp_String.equals("node id")) {
                    i = i + 2;
                    temp_id = get_number_i(linijka, i);
                    right = true;
                } else if (temp_String.equals("lat")) {
                    i = i + 2;
                    temp_szerokosc = get_number_d(linijka, i);
                } else if (temp_String.equals("lon")) {
                    i = i + 2;
                    temp_dlugosc = get_number_d(linijka, i);
                }

            }
        }
        if (right) {// jesli nowy werzocholek i prawidlowy dodaj do listy wierzcholkow
            node_list.add(new TempNode(temp_id, temp_szerokosc, temp_dlugosc));
        }
    }

    private void czytaj_droge(String linijka, ArrayList<TempWay> way_list) {
        int temp_id;
        int temp_ref;
        boolean highway = false;
        int d = linijka.length();
        int licznik = 0;

        for (int i = 0; i < d; i++) {
            if (Character.isLetter(linijka.charAt(i))) {
                String temp_String = get_slowo(linijka, i);
                if (temp_String == "way id") {
                    i = i + 2;
                    temp_id = get_number_i(linijka, i);
                    way_list.add(new TempWay(temp_id));
                } else if (temp_String == "nd ref") {
                    i = i + 2;
                    temp_ref = get_number_i(linijka, i);
                    way_list.get(way_list.size() - 1).getSciezka().add(temp_ref);
                } else if (temp_String.equals("tag k")) {
                    i += 2;
                    String temp_String2 = get_slowo(linijka, i);
                    if (temp_String2 == "highway") {
                        highway = true;
                        licznik++;
                    } else if (temp_String2 == "name") {
                        i += 5;
                        way_list.get(way_list.size() - 1).setNazwa(get_slowo(linijka, i));
                    } else if (temp_String2 == "oneway") {
                        i += 5;
                        if (get_slowo(linijka, i) == "yes") {
                            way_list.get(way_list.size() - 1).setOneway(true);
                        }
                    }
                }
                if (temp_String == "way"   {
                    linijka.charAt(i) == '>'
                }
                
                    ) {
                    if (!way_list.isEmpty()   {
                        highway == true
                    }
                    
                        ) {
                        way_list.remove(way_list.size() - 1);
                    }
                    highway = false;
                }

            }

        }
        //  if (!way_list.empty()  highway==0){way_list.pop_back(); }//zeby usunac ostatnie
    }// usunac ostanie

    private String get_slowo(String s, Integer i) {
        String wynik = "";
        while (Character.isLetter(s.charAt(i)) || s.charAt(i) == ' ') {
            wynik += s.charAt(i);
            i++;
        }
        return wynik;
    }

    private int get_number_i(String s, Integer i) {
        int wynik = 0;
        while (Character.isDigit(s.charAt(i))) {
            wynik = wynik * 10 + s.charAt(i) - '0';
            i++;
        }
        return wynik;
    }

    double get_number_d(String s, Integer i) {
        int temp_i = i;
        int komma = 0;
        boolean minus = false;
        if (s.charAt(i) == '-') {
            minus = true;
            i++;
        }
        double wynik = 0;

        while (Character.isDigit(s.charAt(i)) || s.charAt(i) == '.') {

            if (Character.isDigit(s.charAt(i))) {
                wynik = wynik * 10 + (int) s.charAt(i) - '0';
            } else {
                temp_i = i;
            }
            i++;
        }
        komma = i - temp_i - 1;
        if (minus) {
            wynik *= (-1);
        }
        if (komma != 0) {
            return wynik / Math.pow(10, komma);
        } else {
            return wynik;
        }

    }

    private void zapis_mapy(ArrayList<TempNode> node_list, ArrayList<TempWay> way_list) {

        fstream plik;
        plik.open("mapa_nowa.txt", ios::out);

        int d = way_list.size();
        for (int i = 0; i < d; i++) {
            plik << make_map(node_list, way_list.get(i));
        }

        plik.close();
    }

    private String make_map(ArrayList<TempNode> node_list, TempWay way) {
        int d = way.sciezka.size() - 1;
        String temp_String = "";

        if (way.isOneway() == true) {
            TempNode prev_node = find_node(node_list, way.sciezka.get(0));
            TempNode next_node = prev_node;
            String temp_droga = "";
            for (int i = 0; i < d; i++) {
                if (next_node.id == 0 || prev_node.id == 0) {
                    return "";
                }

                next_node = find_node(node_list, way.sciezka.get(i + 1));

                temp_droga = Integer.toString(prev_node.minus(next_node)) + ",";
                prev_node = next_node;

                temp_String += "(" + way.sciezka.get(i).toString() + ",";
                temp_String += temp_droga;
                temp_String += way.sciezka.get(i + 1).toString() + ")\n";
            }
        } else {
            TempNode prev_node = find_node(node_list, way.sciezka[0]);
            TempNode next_node = prev_node;
            String temp_droga = "";

            for (int i = 0; i < d; i++) {
                if (next_node.id == 0 || prev_node.id == 0) {
                    return "";
                }

                next_node = find_node(node_list, way.sciezka.get(i + 1));

                temp_droga = Integer.toString(prev_node.minus(next_node) + ",";
                prev_node = next_node;
                temp_String += "(" + way.sciezka.get(i).toString() + ",";
                temp_String += temp_droga;
                temp_String += (way.sciezka.get(i + 1)).toString() + ")\n";
                ///
                temp_String += "(" + (way.sciezka.get(i + 1)).toString() + ",";
                temp_String += temp_droga;
                temp_String += (way.sciezka.get(i)).toString() + ")\n";

            }
        }
        return temp_String;
    }

    TempNode find_node(ArrayList<TempNode> node_list, int a) {
        int d = node_list.size();

        int ip = 0;
        int ik = d - 1;
        int isr;
        while (ip <= ik) {

            isr = (ip + ik) >> 1;// szybkie dzielenie na dwa
            if (node_list.get(isr).getId() == a) {
                // cout<<"1";
                return node_list.get(isr);
            } else if (a < node_list.get(isr).getId()) {
                ik = isr - 1;
            } else {
                ip = isr + 1;
            }
        }
        return new TempNode(0, 0, 0);
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;

                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(AlgoTest.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(AlgoTest.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(AlgoTest.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(AlgoTest.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new AlgoTest().setVisible(true);
            }
        });
    }
    Dijkstra dijkstra;
    ArrayList<Node> list;
    ArrayList<TempNode> nodeList;
    ArrayList<TempWay> wayList;
    int start;
    int end;

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnFind;
    private javax.swing.JButton btnFindEndNode;
    private javax.swing.JButton btnFindStartNode;
    private javax.swing.JButton btnLoad;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextPane jTextPane1;
    private javax.swing.JTextField txtEndLat;
    private javax.swing.JTextField txtEndLon;
    private javax.swing.JTextField txtMapFile;
    private javax.swing.JTextField txtStartLat;
    private javax.swing.JTextField txtStartLon;
    // End of variables declaration//GEN-END:variables
}
